package main

import "fmt"

/**
200. 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
[
1["1","1","1","1","1","0","1","1","1","1"],
2["1","0","1","0","1","1","1","1","1","1"],
3["0","1","1","1","0","1","1","1","1","1"],
4["1","1","0","1","1","0","0","0","0","1"],
5["1","0","1","0","1","0","0","1","0","1"],
6["1","0","0","1","1","1","0","1","0","0"],
7["0","0","1","0","0","1","1","1","1","0"],
8["1","0","1","1","1","0","0","1","1","1"],
9["1","1","1","1","1","1","1","1","0","1"],
10["1","0","1","1","1","1","1","1","1","0"]]
**/

func main() {
	//fmt.Println(numIslands([][]byte{[]byte{'1', '1', '1', '1', '0'}, []byte{'1', '1', '0', '1', '0'}, []byte{'1', '1', '0', '0', '0'}, []byte{'0', '0', '0', '0', '0'}}))
	//fmt.Println(numIslands([][]byte{[]byte{'1', '1', '1'}, []byte{'0', '1', '0'}, []byte{'1', '1', '1'}}))
	fmt.Println(numIslands([][]byte{
		[]byte{'1', '1', '1', '1', '1', '0', '1', '1', '1', '1'},
		[]byte{'1', '0', '1', '0', '1', '1', '1', '1', '1', '1'},
		[]byte{'0', '1', '1', '1', '0', '1', '1', '1', '1', '1'},
		[]byte{'1', '1', '0', '1', '1', '0', '0', '0', '0', '1'},
		[]byte{'1', '0', '1', '0', '1', '0', '0', '1', '0', '1'},
		[]byte{'1', '0', '0', '1', '1', '1', '0', '1', '0', '0'},
		[]byte{'0', '0', '1', '0', '0', '1', '1', '1', '1', '0'},
		[]byte{'1', '0', '1', '1', '1', '0', '0', '1', '1', '1'},
		[]byte{'1', '1', '1', '1', '1', '1', '1', '1', '0', '1'},
		[]byte{'1', '0', '1', '1', '1', '1', '1', '1', '1', '0'},
	}))
}

//转换问题为二维数组中有几个树，1相对于是节点(并查集、广度优先、深度优先，后两种遍历了几次就有几个，前面是有几个顶级集合代表节点就有几个)
func numIslands(grid [][]byte) int {
	//存储节点的所属集合的代表节点
	nodes := make(map[int]int)
	//存储顶级集合代表节点
	roots := make(map[int]int)

	findParent := func(index int) int {
		for {
			//如果找的到就返回，找不到就返回0
			if nodes[index] == index {
				return index
			}
			index = nodes[index]
		}
	}

	for i := 0; i < len(grid); i++ {
		length := len(grid[i])
		for j := 0; j < length; j++ {
			if grid[i][j] != '1' {
				continue
			}

			var p1, p2 int
			num := getNum(i, j, length)

			//如果左边有节点
			if j-1 >= 0 && grid[i][j-1] == '1' {
				//且节点能找到集合代表节点
				p1 = findParent(num - 1)
			}

			if i-1 >= 0 && grid[i-1][j] == '1' {
				p2 = findParent(num - length)
			}

			//if num == 79 {
			//	fmt.Println("p1:", p1)
			//	fmt.Println("p2:", p2)
			//	fmt.Println(nodes)
			//}

			//如果都为0那么旁边没有边
			if p1 == p2 {
				if p1 == 0 {
					nodes[num] = num
					roots[num] = num
				} else {
					//如果上左两边都为同一集合，那么该点也为这个集合
					nodes[num] = p1
				}

			}

			if p1 != p2 {
				//设置p2的代表节点为p1
				if p1 != 0 && p2 == 0 {
					nodes[num] = p1
				} else if p2 != 0 && p1 == 0 {
					//合并两集合
					nodes[num] = p2
				} else {
					nodes[p2] = p1
					nodes[num] = p1
					//if num == 8 {
					//	fmt.Println("-----")
					//}
					delete(roots, p2)
					delete(roots, num)
				}
			}
		}
	}

	return len(roots)
}

func getNum(i, j, length int) int {
	return i*length + j + 1
}
